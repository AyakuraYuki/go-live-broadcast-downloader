// 用于生成wtmicro 框架代码（客户端链接池操作）

package main

import (
	"bytes"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
	"io"
	"os"
	"strings"
)

var mapFilterProto = map[string]struct{}{
	"google/api/annotations.proto":     {},
	"google/api/http.proto":            {},
	"google/protobuf/descriptor.proto": {},
}

func main() {
	input, _ := io.ReadAll(os.Stdin)
	var req pluginpb.CodeGeneratorRequest
	_ = proto.Unmarshal(input, &req)

	opts := protogen.Options{}
	plugin, err := opts.New(&req)
	if err != nil {
		panic(fmt.Errorf("a. %v", err))
	}

	for _, file := range plugin.Files {
		var buf bytes.Buffer
		if _, ok := mapFilterProto[file.Proto.GetName()]; ok {
			continue
		}
		if len(file.Proto.Service) == 0 {
			continue
		}

		buf.Write([]byte("// Code generated by protoc-gen-wtmicro. DO NOT EDIT.\n"))
		buf.Write([]byte("// 旨在grpc 客户端方便调用.\n"))
		pkg := fmt.Sprintf("package %s", file.GoPackageName)
		buf.Write([]byte(pkg))
		buf.Write([]byte(`

import (
	"context"
	pool "go-live-broadcast-downloader/plugins/grpcpool"
	"go-live-broadcast-downloader/plugins/log"
	"go-live-broadcast-downloader/plugins/trace/grpc_trace"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"sync"
)
`))
		serviceComment := file.Services[0].Comments.Leading.String()
		serviceName := file.Proto.Service[0].GetName()
		_, err = buf.Write([]byte(fmt.Sprintf(`
var (
	svrSyncMap sync.Map
)

type %sClientService struct {
	name    string
	address string
	opts    *pool.Options
	pool    *pool.Pool
	lock    sync.Mutex
}

func (cs *%sClientService) getPool() (*pool.Pool, error) {
	if cs.pool != nil && !cs.pool.IsClosed() {
		return cs.pool, nil
	}
	cs.lock.Lock()
	defer cs.lock.Unlock()
	p, err := pool.New(func() (*grpc.ClientConn, error) {
		return grpc.Dial(cs.address, grpc.WithInsecure(), grpc.WithUnaryInterceptor(grpc_trace.UnaryClientInterceptor()))
	}, cs.opts)
	if err != nil {
		log.Error("GetGRPCPool").Msg(err)
		return nil, err
	}
	cs.pool = p
	return p, nil
}

%sfunc New%sClientService(serviceName string, address string, opts *pool.Options) *%sClientService {
	val, ok := svrSyncMap.Load(serviceName)
	if ok {
		if cs, ok2 := val.(*%sClientService); ok2 {
			return cs
		}
	}
	if opts == nil {
		opts = &pool.Options{
			Init:            pool.DefaultOptions.Init,
			MaxActive:       pool.DefaultOptions.MaxActive,
			IdleTimeout:     pool.DefaultOptions.IdleTimeout,
			MaxLifeDuration: pool.DefaultOptions.MaxLifeDuration,
		}
	}
	newClientService := &%sClientService{
		name:    serviceName,
		address: address,
		opts:    opts,
	}
	newClientService.pool, _ = newClientService.getPool()
	svrSyncMap.Store(serviceName, newClientService)
	return newClientService
}

func (cs *%sClientService) Close() {
	svrSyncMap.Delete(cs.name)
	if cs.pool == nil || cs.pool.IsClosed() {
		return
	}
	cs.pool.Close()
}
`, serviceName, serviceName, serviceComment, serviceName, serviceName, serviceName, serviceName, serviceName)))
		if err != nil {
			panic(fmt.Errorf("b. %v", err))
		}
		for index, v := range file.Proto.Service[0].GetMethod() {
			methodName := v.GetName()
			methodComment := file.Services[0].Methods[index].Comments.Leading.String()
			methodComment = strings.Replace(methodComment, "//", "", 1)
			if methodComment == "" {
				methodComment = "\n"
			}

			reqArr := strings.Split(v.GetInputType(), ".")
			reqStr := reqArr[len(reqArr)-1]
			rspArr := strings.Split(v.GetOutputType(), ".")
			rspStr := rspArr[len(rspArr)-1]
			methodStr := fmt.Sprintf(`
// %s %sfunc (cs *%sClientService) %s(ctx context.Context, req *%s, opts ...grpc.CallOption) (rsp *%s, err error) {
	p, err := cs.getPool()
	if err != nil {
		return nil, err
	}
	if p == nil || p.IsClosed() {
		return nil, pool.ErrClosed
	}
	conn, err := p.Get(ctx)
	if err != nil {
		log.Error("%s.%s").Msg(err)
		return nil, err
	}
	defer conn.Close()

	if len(opts) == 0 {
		opts = pool.DefaultGrpcCallOpts()
	}
	cli := New%sClient(conn.ClientConn)
	rsp, err = cli.%s(ctx, req, opts...)
	if err != nil {
		tmpCode := status.Code(err)
		if tmpCode == codes.Unavailable {
			conn.Unhealthy()
		}
		log.Error("%s.%s").Msg(err)
		return nil, err
	}
	return rsp, err
}
`, methodName, methodComment, serviceName, methodName, reqStr, rspStr, serviceName, methodName, serviceName, methodName, serviceName, methodName)
			buf.Write([]byte(methodStr))
		}

		filename := file.GeneratedFilenamePrefix + ".wtmicro.client"
		file := plugin.NewGeneratedFile(filename, ".")
		_, err = file.Write(buf.Bytes())
		if err != nil {
			panic(fmt.Errorf("c. %v", err))
		}
	}
	stdout := plugin.Response()
	out, err := proto.Marshal(stdout)
	if err != nil {
		panic(err)
	}

	_, _ = fmt.Fprintf(os.Stdout, "%s", string(out))
}
